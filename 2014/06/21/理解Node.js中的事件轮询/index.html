<!DOCTYPE html><html><head><meta charset="utf-8"><title>理解Node.js中的事件轮询 | Andimeo&#39;s Blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="本文翻译自Mixu的文章Understanding the Node.js event loop  Node.js的第一个基本观点是，I&#x2F;O是昂贵的。    L1-cache: 3 cycles L2-cache: 14 cycles RAM: 250 cycles Disk: 41 000 000 cycles Network: 240 000 000 cycles  所以现在编程技术中最大的"><meta property="og:type" content="article"><meta property="og:title" content="理解Node.js中的事件轮询"><meta property="og:url" content="https://andimeo.us.kg/2014/06/21/%E7%90%86%E8%A7%A3Node.js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/index.html"><meta property="og:site_name" content="Andimeo&#39;s Blog"><meta property="og:description" content="本文翻译自Mixu的文章Understanding the Node.js event loop  Node.js的第一个基本观点是，I&#x2F;O是昂贵的。    L1-cache: 3 cycles L2-cache: 14 cycles RAM: 250 cycles Disk: 41 000 000 cycles Network: 240 000 000 cycles  所以现在编程技术中最大的"><meta property="og:locale"><meta property="og:image" content="https://andimeo.us.kg/img/Memory_Apache_Nginx_Comparison.jpg"><meta property="og:image" content="https://andimeo.us.kg/img/EventLoop.jpg"><meta property="article:published_time" content="2014-06-20T16:34:00.000Z"><meta property="article:modified_time" content="2024-09-07T07:25:33.408Z"><meta property="article:author" content="Andimeo"><meta property="article:tag" content="译文"><meta property="article:tag" content="Node.js"><meta property="article:tag" content="事件轮询"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://andimeo.us.kg/img/Memory_Apache_Nginx_Comparison.jpg"><link rel="alternative" href="/atom.xml" title="Andimeo&#39;s Blog" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link href="http://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/style.css"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation"><div class="container"><button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">Andimeo&#39;s Blog</a><div class="collapse navbar-collapse nav-menu"><ul class="nav navbar-nav"><li><a href="/archives/"><i class="fa fa-archive"></i> Archives</a></li><li><a href="/categories/"><i class="fa fa-folder"></i> Categories</a></li><li><a href="/tags/"><i class="fa fa-tags"></i> Tags</a></li><li><a href="/about/"><i class="fa fa-user"></i> About</a></li></ul><ul class="nav navbar-nav navbar-right"><li><a id="rss-link" href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li></ul></div></div></nav><div class="clearfix"></div><div id="content" class="container"><div class="page-header-wrapper"><!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a target="_blank" rel="noopener" href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a target="_blank" rel="noopener" href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]--><div class="page-header"><h1 class="title">理解Node.js中的事件轮询</h1></div></div><section id="main"><article id="post-cm10lqxfc0027rdy73qova3qp" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><div class="article-entry" itemprop="articleBody"><div id="toc"><span class="toc-header">Contents</span><ol class="article-toc"><li class="article-toc-item article-toc-level-3"><a class="article-toc-link" href="#node.js%E5%8F%AA%E4%B8%BA%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BF%9D%E7%95%99%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="article-toc-text">Node.js只为你的代码保留一个线程</span></a></li><li class="article-toc-item article-toc-level-3"><a class="article-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%81%9A%E6%98%AF%E5%A5%BD%E7%9A%84%EF%BC%9F%E6%88%91%E4%BB%AC%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BB%8E%E5%90%8C%E6%AD%A5%E8%B7%B3%E5%88%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%AD%EF%BC%9F"><span class="article-toc-text">为什么这么做是好的？我们什么时候从同步跳到异步的执行中？</span></a></li><li class="article-toc-item article-toc-level-3"><a class="article-toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8node.js%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="article-toc-text">如何在Node.js中进行异步操作</span></a></li></ol></div><blockquote><p>本文翻译自Mixu的文章<a target="_blank" rel="noopener" href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/">Understanding the Node.js event loop</a></p></blockquote><p><strong>Node.js的第一个基本观点是，I/O是昂贵的。</strong></p><ul><li>L1-cache: 3 cycles</li><li>L2-cache: 14 cycles</li><li>RAM: 250 cycles</li><li>Disk: 41 000 000 cycles</li><li>Network: 240 000 000 cycles</li></ul><p>所以现在编程技术中最大的浪费来自对I/O的等待。我们有几种方法用来可以应对I/O：</p><ol><li>同步：按序执行每一个请求。优点：简单。缺点：任何一个请求都可能会阻塞其他请求。</li><li>进程：对每个请求，我们都开一个新的进程来处理。优点：容易。缺点：扩展性不好，有几百个请求的话，就需要几百个进程来处理。fork()是Unix程序员的万精油。因为它的使用，所有问题看起来都微不足道。但是往往并不需要这么“重”的解决方法。</li><li>线程：对每个请求，开一个新的线程进行处理。优点：容易，而且相比进程而言，对内核更加友好，因为线程使用的系统资源往往比进程要少。缺点：首先你的机器可能不支持线程。其次因为要考虑对共享资源的访问控制，很快线程编程就会变得非常复杂。</li></ol><span id="more"></span><p><strong>Node.js的第二个基本观点是，每个请求用一个线程来处理的方式会耗费过多的内存。</strong>(如同那张人尽皆知的图，与Nginx想比，Apache消耗了大量内存)</p><p><img src="/img/Memory_Apache_Nginx_Comparison.jpg" alt="Memory Apache Nginx Comparison" title="Memory Apache Nginx Comparison"></p><p>Apache是多线程的，它每次都会为新请求创建一个新线程（或者进程，这取决于怎么配置）。你可以看到随着并发连接数的增多，不仅消耗的内存越来越多，同时也需要更多的线程来服务这些同时发起请求的客户端。Ngnix和Node.js不是多线程的，因为线程和进程都会耗费过多的内存。Ngnix和Node.js是单线程的，但是是基于事件的。通过在一个线程中处理所有连接，从而消除因为创建多个线程或进程而消耗的系统资源。</p><h3 id="node.js只为你的代码保留一个线程">Node.js只为你的代码保留一个线程</h3><p>它真的只有一个线程，你不能并行执行代码。如果你“sleep”一秒钟，将会阻塞整个server一秒钟：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() &lt; now + <span class="number">1000</span>) &#123;</span><br><span class="line">   <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">所以当上面的代码执行的时候，Node.js将不会响应任何来自客户端的请求，因为它只有一个线程在执行你的代码。或者假如你有一些CPU密集型的代码，比如图片缩放，这仍然会阻塞所有其他的请求。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 所有的代码都是并行执行的，除了你的代码</span></span><br><span class="line"><span class="string">其实在一个线程里让代码并行执行是不可能的。然而，所有的I/O都是基于事件和异步的，那么就不会阻塞server。  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line">c.<span class="title function_">query</span>(</span><br><span class="line">   <span class="string">&#x27;SELECT SLEEP(20);&#x27;</span>,</span><br><span class="line">   <span class="keyword">function</span> (<span class="params">err, results, fields</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">throw</span> err;</span><br><span class="line">     &#125;</span><br><span class="line">     res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line">     res.<span class="title function_">end</span>(<span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Return from async DB query&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>);</span><br><span class="line">     c.<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果在一个请求处理中这么做，那么在查询数据库的时候，其他请求仍然能够被正确处理。</p><h3 id="为什么这么做是好的？我们什么时候从同步跳到异步的执行中？">为什么这么做是好的？我们什么时候从同步跳到异步的执行中？</h3><p>同步执行有它的优点，因为这样简化了代码的编写。</p><p>在Node.js中，你不用担心后端发生了什么，只要在需要I/O的时候使用回调函数就行了。你的代码确保不会被打断，而且I/O不会阻塞其他的请求，也不会带来因为过多线程或进程导致的资源消耗。</p><p>让I/O异步执行是好的，因为I/O比大部分代码的执行更加昂贵，我们不应该仅仅在I/O的时候等在那里。 <img src="/img/EventLoop.jpg" alt="EventLoop" title="EventLoop"> 事件轮询可以处理外部的事件，并且将他们转化为回调函数的调用。所以Node.js可以在I/O调用时从这个请求转向其他的请求。在I/O调用中，你的代码保存回调函数，并将控制权交给Node.js的运行时环境，回调函数将在I/O结束后被调用。</p><p>当然，在后端，有别的线程或者进程在执行I/O操作。然而这些并不会暴露在你的代码中，所以你并不用担心它们。但是你应该知道I/O操作，如数据库操作，或者其他的一些任务将会是异步执行的，这些线程的结果将通过事件轮询返回到每个请求的处理过程中。与Apache的模型相比，线程数和线程对资源的消耗下降了很多，因为我们并不需要为每个连接开一个线程。除非当你确实有些事情需要并行处理，才需要在此时开一个线程。而且在Node.js中，线程并不需要你来管理。</p><p>除了I/O调用外，Node.js希望所有的请求都能够快速返回，如：CPU密集型的工作应该交给另一个线程来处理。这个线程将会以事件的形式和你进行交互。这意味着，要想在后台有独立的线程存在，你只有使用事件这一种方法。基本上，所有会发布事件的对象都支持异步调用，而且你可以和这些阻塞中的代码进行交互，通过文件、socket或者子进程，所有的这些在Node.js中都叫做EventEmitter。我们可以使用这种方法来充分利用多核，另见：node-http-proxy。</p><p><strong>内部实现</strong><br>在内部，libev为Node.js提供事件轮询，libeio提供线程池来支持异步I/O。如果想学习更多，可以看看libev的文档。</p><h3 id="如何在node.js中进行异步操作">如何在Node.js中进行异步操作</h3><ul><li>我们将函数作为参数进行传递，在需要的地方执行</li><li>匿名函数，或称为闭包，当事件I/O中结束时执行</li><li>回调计数，对于事件回调，我们并不能保证这些事件完成的顺序。所以如果你需要等待多个事件执行结束，通常你只需要保存一个并行操作的计数器，然后检查是否所有事件都执行结束。比如在回调中记录DB查询返回的个数。</li><li>事件轮询，如之前所述，你可以把阻塞代码转变为一个事件，让另一个线程来执行，并当执行结束后将结果返回。</li></ul><p>就是这么简单！</p></div></div></article><section id="comments"><div id="disqus_thread"></div><script>var disqus_config=function(){this.page.url="https://andimeo.us.kg/2014/06/21/%E7%90%86%E8%A7%A3Node.js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/",this.page.identifier="8c507bdb-6ba7-11ef-80cf-1747159a1056"};!function(){var e=document,t=e.createElement("script");t.src="https://andimeo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)}()</script><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></section></section><aside id="sidebar"><div class="widget-wrap center"><ul class="pagination"><li><a href="/2014/06/27/配置mod_cluster与tomcat/" class="nav-prev">Prev</a></li><li><a data-url="https://andimeo.us.kg/2014/06/21/%E7%90%86%E8%A7%A3Node.js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/" data-id="cm10lqxfc0027rdy73qova3qp" data_title="理解Node.js中的事件轮询" data_summary="
本文翻译自Mixu的文章Understanding the Node.js event loop

Node.js的第一个基本观点是，I/O是昂贵的。  

L1-cache: 3 cycles
L2-cache: 14 cycles
RAM: 250 cycles
Di..." class="article-share-link">Share</a></li><li><a href="/2014/06/14/大学之美/" class="nav-next">Next</a></li></ul></div><div class="widget-wrap"><div class="post-widget"><i class="fa fa-clock-o"></i> <time datetime="2014-06-20T16:34:00.000Z" itemprop="datePublished">2014-06-21</time></div></div><div class="widget-wrap"><div class="post-widget"><i class="fa fa-folder"></i> <a class="category-link" href="/categories/Node-js/">Node.js<span class="category-count">1</span></a></div></div><div class="widget-wrap"><div class="post-widget"><i class="fa fa-tags"></i> <a class="tag-none-link" href="/tags/Node-js/" rel="tag">Node.js<span class="tag-none-count">1</span></a><a class="tag-none-link" href="/tags/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/" rel="tag">事件轮询<span class="tag-none-count">1</span></a><a class="tag-none-link" href="/tags/%E8%AF%91%E6%96%87/" rel="tag">译文<span class="tag-none-count">3</span></a></div></div></aside></div><footer id="footer"><div class="outer container"><div id="footer-info" class="inner"><a href="/">Andimeo&#39;s Blog</a> &copy; 2024 Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/Andimeo/hexo-theme-nut" target="_blank">Nut</a></div></div></footer><a id="gotop" href="#"><i class="fa fa-chevron-up"></i></a></div><nav id="mobile-nav"><a href="[object Object]" class="mobile-nav-link">0</a> <a href="[object Object]" class="mobile-nav-link">1</a> <a href="[object Object]" class="mobile-nav-link">2</a> <a href="[object Object]" class="mobile-nav-link">3</a></nav><script src="/js/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/js/jquery.fitvids.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/script.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} 
});</script><script type="text/javascript" src="/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="dsq-count-scr" src="//andimeo.disqus.com/count.js" async></script></div></body></html>